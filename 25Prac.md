Вот текст из файла методических указаний к практическому занятию:

---

**ДИСЦИПЛИНА** Фронтенд и бэкенд разработка  
**ИНСТИТУТ** ИПТИП  
**КАФЕДРА** Индустриального программирования  
**ВИД УЧЕБНОГО МАТЕРИАЛА** Методические указания к практическим занятиям  
**ПРЕПОДАВАТЕЛЬ** Астафьев Рустам Уралович  
**СЕМЕСТР** 1 семестр, 2025/2026 уч. год

**Ссылка на материал:** https://github.com/astafiev-rustam/frontend-and-backend-development/tree/practice-1-25

# Практическое занятие 25: Формы React: валидация, сообщения об ошибках и элементы доступности

В рамках данного занятия будут рассмотрены возможности работы с формами в React и обеспечением доступности. Материалы занятия соответствуют представлениям о формировании ввода и доступности страниц из предыдущих практик и лекций.

## Теоретическая часть

### Пример 1. Форма с валидацией в реальном времени

**Проблема:** Нужно создать форму добавления технологии с валидацией полей в реальном времени и понятными сообщениями об ошибках.

**Подход к решению:** Используем состояние для хранения ошибок, проверяем валидность при каждом изменении и блокируем отправку при ошибках.

**Пошаговая реализация:**

**Шаг 1: Настройка состояний формы и параметра initialData**

Компонент TechnologyForm принимает props от родительского компонента:

```javascript
function TechnologyForm({ onSave, onCancel, initialData = {} }) {
	// ...
}
```

**Пропс initialData:**  
initialData - это объект с данными технологии, который передается родительским компонентом:

Когда создаем новую технологию родитель вызывает компонент БЕЗ initialData:

```javascript
<TechnologyForm onSave={handleSave} onCancel={handleCancel} />
// initialData будет пустым объектом {} (значение по умолчанию)
```

Когда редактируем существующую технологию, родитель передает данные:

```javascript
<TechnologyForm
	onSave={handleSave}
	onCancel={handleCancel}
	initialData={{
		title: 'React Hooks',
		description: 'Изучение хуков useState и useEffect',
		category: 'frontend',
		difficulty: 'intermediate',
		deadline: '2024-12-31',
		resources: ['https://react.dev', 'https://example.com/tutorial'],
	}}
/>
```

**Что такое "ресурсы" (resources):**  
Ресурсы - это массив URL-адресов полезных материалов для изучения технологии. Пользователь может динамически добавлять/удалять поля для ресурсов. Минимум должно быть одно поле.

**Создаем три основных состояния:**

```javascript
// состояние формы с начальными значениями
const [formData, setFormData] = useState({
	title: initialData.title || '', // название технологии
	description: initialData.description || '', // описание
	category: initialData.category || 'frontend', // категория
	difficulty: initialData.difficulty || 'beginner', // сложность
	deadline: initialData.deadline || '', // дедлайн (необязательно)
	resources: initialData.resources || [''], // массив URL ресурсов
})

// состояние для хранения ошибок валидации
const [errors, setErrors] = useState({})

// флаг валидности всей формы
const [isFormValid, setIsFormValid] = useState(false)
```

**Назначение:**

- `formData` хранит все значения полей. Используем `initialData.field || defaultValue` для инициализации
- `errors` - объект с сообщениями об ошибках `{ title: 'Название обязательно' }`
- `isFormValid` - можно ли отправить форму (true/false)

**Почему `resources: initialData.resources || ['']`:**

- При редактировании: берем существующий массив ресурсов
- При создании: инициализируем массив с одним пустым полем `['']`
- Гарантирует наличие минимум одного поля для ввода URL

**Шаг 2: Функция валидации с обнулением времени**

```javascript
const validateForm = () => {
	const newErrors = {}
	// валидация названия технологии
	if (!formData.title.trim()) {
		newErrors.title = 'Название технологии обязательно'
	}

	// валидация дедлайна (не должен быть в прошлом)
	if (formData.deadline) {
		const deadlineDate = new Date(formData.deadline)
		const today = new Date()
		today.setHours(0, 0, 0, 0)

		if (deadlineDate < today) {
			newErrors.deadline = 'Дедлайн не может быть в прошлом'
		}
	}

	setErrors(newErrors)
	setIsFormValid(Object.keys(newErrors).length === 0)
}
```

**`today.setHours(0, 0, 0, 0):`**  
Эта строка обнуляет время у сегодняшней даты, оставляя только дату.

**Зачем это нужно:**

- **Без обнуления времени:** пользователь, выбравший сегодняшнюю дату как дедлайн, получит ошибку валидации, потому что текущее время дня будет позже полуночи.
- **С обнулением времени:** даты сравниваются корректно, игнорируя текущее время дня.

**Итог:** обнуление времени позволяет сравнивать только даты, игнорируя текущее время дня.

**Шаг 3: Запуск валидации при изменении данных**

```javascript
useEffect(() => {
	validateForm()
}, [formData])
```

**Назначение:** каждый раз когда пользователь меняет любое поле, автоматически запускается валидация. Это обеспечивает валидацию в реальном времени без задержек.

**Шаг 4: Обработчик изменения конкретного ресурса**

```javascript
const handleResourceChange = (index, value) => {
	const newResources = [...formData.resources]
	newResources[index] = value
	setFormData(prev => ({
		...prev,
		resources: newResources,
	}))
}
```

**Подробное объяснение работы:**

Допустим, у нас есть такое состояние:

```javascript
formData.resources = [
	'https://react.dev', // индекс 0
	'https://nodejs.org', // индекс 1
	'', // индекс 2 (пустое поле)
]
```

Пользователь вводит текст во второе поле (индекс 1). Вызывается `handleResourceChange(1, 'https://nodejs.org/docs');`

**Шаг 1:** Создаем копию массива  
`const newResources = [...formData.resources];`  
`[...]` - spread оператор создает НОВУЮ копию массива (важно для иммутабельности)

**Шаг 2:** Обновляем нужный элемент по индексу  
`newResources[1] = 'https://nodejs.org/docs';`

**Шаг 3:** Обновляем состояние

```javascript
setFormData(prev => ({
	...prev, // сохраняем все остальные поля
	resources: newResources, // заменяем только массив resources
}))
```

**Итог:** React увидит изменение состояния и перерендерит компонент. Второе поле покажет новое значение.

**Шаг 5: Добавление и удаление полей ресурсов**

```javascript
// добавление нового пустого поля для ресурса
const addResourceField = () => {
	setFormData(prev => ({
		...prev,
		resources: [...prev.resources, ''],
	}))
}

// удаление поля ресурса по индексу
const removeResourceField = index => {
	if (formData.resources.length > 1) {
		const newResources = formData.resources.filter((_, i) => i !== index)
		setFormData(prev => ({
			...prev,
			resources: newResources,
		}))
	}
}
```

**Подробное объяснение `addResourceField`:**

Начальное состояние:  
`formData.resources = ['https://react.dev', 'https://nodejs.org']`

Пользователь нажимает "+ Добавить ресурс". Выполняется:

```javascript
resources: [...prev.resources, '']
// результат: ['https://react.dev', 'https://nodejs.org', '']
```

**`removeResourceField` и `filter((_, i) => i !== index)`:**  
В JavaScript `_` - это обычное имя переменной. Используется как соглашение для обозначения неиспользуемого параметра.

Метод `filter` вызывает функцию для каждого элемента с двумя параметрами:

1. Сам элемент (значение)
2. Индекс элемента

**Пример удаления:**

```javascript
// массив: ['https://react.dev', 'https://nodejs.org', 'https://example.com']
// удаляем индекс 1 (второй элемент)
filter((_, i) => i !== 1)
// результат: ['https://react.dev', 'https://example.com']
```

**Проверка `if (formData.resources.length > 1)`:** гарантирует что минимум одно поле всегда останется.

**Шаг 9: Обработка отправки формы с очисткой пустых ресурсов**

```javascript
const handleSubmit = e => {
	e.preventDefault()
	if (isFormValid) {
		// очищаем пустые ресурсы перед сохранением
		const cleanedData = {
			...formData,
			resources: formData.resources.filter(resource => resource.trim() !== ''),
		}
		onSave(cleanedData)
	}
}
```

**Подробное объяснение `resources.filter(resource => resource.trim() !== '')`:**  
Эта строка удаляет все пустые или заполненные только пробелами поля ресурсов перед отправкой данных.

**Ситуация:** Пользователь добавил три поля для ресурсов, но заполнил только два:

```javascript
formData.resources = [
	'https://react.dev', // заполнено
	'https://nodejs.org', // заполнено
	'', // пустое поле
]
```

**Как работает `filter`:**

```javascript
resources.filter(resource => resource.trim() !== '')
// Вызов 1: 'https://react.dev'.trim() -> 'https://react.dev' !== '' -> true -> ОСТАВЛЯЕМ
// Вызов 2: 'https://nodejs.org'.trim() -> 'https://nodejs.org' !== '' -> true -> ОСТАВЛЯЕМ
// Вызов 3: ''.trim() -> '' !== '' -> false -> УДАЛЯЕМ
// результат: ['https://react.dev', 'https://nodejs.org']
```

**Зачем нужен `trim()`:**  
Метод `trim()` удаляет пробелы с начала и конца строки:

- `' '.trim() === ''` - true (только пробелы стали пустой строкой)
- `' hello '.trim() === 'hello'` - true (пробелы убраны с краев)

Это защищает от "псевдозаполненных" полей, где пользователь случайно ввел только пробелы.

**Итоговые данные для отправки:**

```javascript
cleanedData = {
	title: 'React Hooks',
	description: 'Изучение хуков',
	category: 'frontend',
	difficulty: 'intermediate',
	deadline: '2024-12-31',
	resources: ['https://react.dev', 'https://nodejs.org'], // только заполненные URL
}
```

**Зачем это нужно:** на сервер или в родительский компонент попадают только реально заполненные ресурсы, без пустых строк.

_(Полный исходный код TechnologyForm.jsx представлен в PDF документе)_

### Пример 2. Доступная форма с ARIA атрибутами

**Проблема:** Нужно создать форму, которая корректно работает со скринридерами и другими вспомогательными технологиями.

**Подход к решению:** Используем ARIA атрибуты для обеспечения доступности, правильные связи между элементами и объявление статуса операций.

**Пошаговое объяснение реализации:**

**Шаг 1: Создание области для объявлений скринридерами**

Добавляем скрытый элемент, который будет объявлять статус отправки формы пользователям скринридеров:

```javascript
<div role='status' aria-live='polite' aria-atomic='true' className='sr-only'>
	{isSubmitting && 'Отправка формы...'}
	{submitSuccess && 'Форма успешно отправлена!'}
</div>
```

**Подробное объяснение `aria-live="polite"`:**  
Атрибут `aria-live` указывает скринридеру отслеживать изменения содержимого элемента и объявлять их пользователю. Есть три возможных значения:

1. **"off"** (по умолчанию) - не объявлять изменения
2. **"polite"** - объявить изменения когда скринридер закончит текущее чтение
3. **"assertive"** - немедленно прервать текущее чтение и объявить изменения

**Сравнение `polite` и `assertive`:**

- **polite** - вежливое объявление: скринридер заканчивает текущую фразу, затем объявляет изменения
- **assertive** - агрессивное прерывание: скринридер немедленно прерывается и объявляет изменения

**Когда использовать:**

- **"polite"** для некритичной информации: статус отправки формы, уведомления, загрузка данных
- **"assertive"** для срочной информации: критические ошибки, предупреждения безопасности, таймеры

Для статуса отправки формы используем `"polite"`, чтобы не прерывать пользователя резко.

**Подробное объяснение `aria-atomic="true"`:**  
Атрибут `aria-atomic` контролирует, что именно объявляется при изменении содержимого:

- **"false"** (по умолчанию) - объявить только изменившуюся часть
- **"true"** - объявить весь контент элемента целиком

**Когда использовать:**

- **"true"** когда изменение теряет смысл без контекста (счетчики, статусы)
- **"false"** когда изменяющаяся часть самодостаточна (список элементов)

Мы используем `"true"`, чтобы пользователь услышал полное сообщение "Форма успешно отправлена!", а не просто `"true"`.

**CSS класс `sr-only` (screen reader only):**  
Элемент скрыт визуально, но доступен для скринридеров:

```css
.sr-only {
	position: absolute;
	width: 1px;
	height: 1px;
	padding: 0;
	margin: -1px;
	overflow: hidden;
	clip: rect(0, 0, 0, 0);
	white-space: nowrap;
	border-width: 0;
}
```

**Шаг 2: Связывание полей с ошибками и двойное отрицание**

```javascript
;<input
	id='contact-name'
	type='text'
	value={name}
	onChange={e => setName(e.target.value)}
	aria-required='true'
	aria-invalid={!!errors.name}
	aria-describedby={errors.name ? 'name-error' : undefined}
	className={errors.name ? 'error' : ''}
/>
{
	errors.name && (
		<span id='name-error' className='error-text' role='alert'>
			{errors.name}
		</span>
	)
}
```

**Назначение ARIA атрибутов:**

- `aria-required="true"` - сообщает что поле обязательное
- `aria-invalid={!!errors.name}` - указывает валидно ли поле (true/false)
- `aria-describedby="name-error"` - связывает поле с описанием ошибки по ID
- `role="alert"` на ошибке - скринридер немедленно объявит ошибку

**`!!` (двойное отрицание):**  
Двойное отрицание `!!` преобразует любое значение в строгий boolean (`true` или `false`).

**Примеры с разными значениями:**

- `!!''` - false (пустая строка - falsy)
- `!!'текст'` - true (непустая строка - truthy)
- `!!0` - false (ноль - falsy)
- `!!42` - true (число не ноль - truthy)
- `!!null` - false (null - falsy)
- `!!undefined` - false (undefined - falsy)
- `!!{}` - true (любой объект - truthy)
- `!![]` - true (любой массив - truthy)
- `!!false` - false (boolean false - falsy)
- `!!true` - true (boolean true - truthy)

**Альтернативы двойного отрицания:**

```javascript
// вариант 1: двойное отрицание (короткий, идиоматичный)
aria-invalid={!!errors.name}

// вариант 2: явное сравнение (понятный, многословный)
aria-invalid={errors.name !== undefined}

// вариант 3: Boolean конструктор (редко используется)
aria-invalid={Boolean(errors.name)}
```

Мы используем `!!` потому что это короткая и широко принятая идиома в JavaScript для преобразования в boolean.

_(Полный исходный код WorkingAccessibleForm.jsx представлен в PDF документе)_

### Пример 3. Импорт и экспорт данных в JSON

**Проблема:** Нужно создать функционал для экспорта данных в JSON-файл и импорта данных из файла.

**Подход к решению:** Используем FileReader API для чтения файлов, Blob для создания файлов, и localStorage для сохранения данных между сессиями.

**Пошаговое объяснение реализации:**

#### Шаг 1: Экспорт данных в JSON-файл с подробным разбором

```javascript
const exportToJSON = () => {
	try {
		const dataStr = JSON.stringify(technologies, null, 2)
		const dataBlob = new Blob([dataStr], { type: 'application/json' })
		const url = URL.createObjectURL(dataBlob)
		const link = document.createElement('a')
		link.href = url
		link.download = `technologies_${
			new Date().toISOString().split('T')[0]
		}.json`
		document.body.appendChild(link)
		link.click()
		document.body.removeChild(link)
		URL.revokeObjectURL(url)
		setStatus('Данные экспортированы в JSON')
	} catch (error) {
		setStatus('Ошибка экспорта данных')
	}
}
```

**`JSON.stringify(technologies, null, 2):`**  
Метод `JSON.stringify()` преобразует JavaScript объект или массив в JSON-строку. Принимает три параметра:

1. **Параметр 1: value** - данные для преобразования (technologies - массив технологий)
2. **Параметр 2: replacer** - функция или массив для фильтрации свойств (null = включить все свойства)
3. **Параметр 3: space** - отступы для форматирования (2 = использовать 2 пробела для отступов)

**Зачем используем `(technologies, null, 2)`:**

- `technologies` - наши данные для экспорта
- `null` - сохраняем все свойства объектов без фильтрации
- `2` - форматируем с отступом 2 пробела для читаемости человеком

**Blob:**  
Blob (Binary Large Object) - это объект, представляющий неизменяемые сырые данные, похожие на файл. Используется для работы с бинарными или текстовыми данными как с файлом.

**Создание Blob:**

```javascript
const dataBlob = new Blob([dataStr], { type: 'application/json' })
```

**Схема работы экспорта:**

```
JavaScript данные
  → JSON.stringify()
  → JSON-строка
  → new Blob()
  → Blob объект
  → URL.createObjectURL()
  → blob://... URL
  → скачивание файла
```

**Зачем нужен Blob:** позволяет работать с данными как с файлом - создать URL для скачивания, отправить на сервер через FormData, прочитать через FileReader.

#### Шаг 2: Импорт данных с FileReader и readAsText

```javascript
const importFromJSON = event => {
	const file = event.target.files[0]
	if (!file) return

	const reader = new FileReader()

	reader.onload = e => {
		try {
			const imported = JSON.parse(e.target.result)

			if (!Array.isArray(imported)) {
				throw new Error('Неверный формат данных')
			}

			setTechnologies(imported)
			setStatus(`Импортировано ${imported.length} технологий`)
		} catch (error) {
			setStatus('Ошибка импорта: неверный формат файла')
		}
	}

	reader.readAsText(file)
	event.target.value = ''
}
```

**Зачем вызывается `reader.readAsText(file)`:**  
**Проблема:** мы не можем напрямую получить содержимое File объекта.

**Решение - FileReader API:**  
FileReader - это API для асинхронного чтения содержимого файлов, выбранных пользователем.

**Методы FileReader:**

- `reader.readAsText(file);` - для текстовых файлов (.txt, .json, .csv) → строка
- `reader.readAsDataURL(file);` - для изображений → base64 строка
- `reader.readAsArrayBuffer(file);` - для любых файлов → бинарные данные

**Почему чтение асинхронное:**

- файл может быть большим (несколько МБ или ГБ)
- синхронное чтение заблокировало бы UI браузера
- асинхронное чтение не замораживает интерфейс

**Схема работы импорта:**

```
Пользователь выбирает файл
→ event.target.files[0]
→ File объект (только метаданные, без содержимого)
→ reader.readAsText(file)
→ браузер читает файл асинхронно
→ reader.onload срабатывает когда чтение завершено
→ e.target.result содержит текст файла
→ JSON.parse() преобразует строку в объект
→ setTechnologies() обновляет состояние
```

**Зачем нужно `event.target.value = ''`:**  
**Проблема:** браузер не вызывает событие `onChange` если пользователь выбирает тот же самый файл повторно.

**Ситуация без очистки:**

1. Пользователь выбирает data.json → onChange срабатывает, файл импортирован
2. Пользователь исправляет data.json в редакторе
3. Пользователь снова выбирает data.json → onChange НЕ СРАБАТЫВАЕТ, потому что значение не изменилось → файл не импортируется заново

**Решение - очистка значения:**  
`event.target.value = '';` - очищаем input после чтения файла

**Ситуация с очисткой:**

1. Пользователь выбирает data.json → onChange срабатывает → input.value очищается до ''
2. Пользователь исправляет data.json
3. Пользователь снова выбирает data.json → input.value меняется с '' на путь к файлу → onChange СРАБАТЫВАЕТ → файл импортируется с новыми данными

**Практический пример:**

1. Импортировали data.json с 5 технологиями → input.value = ''
2. Добавили в data.json еще 3 технологии в редакторе
3. Импортировали data.json снова → onChange сработает → теперь 8 технологий

**Без очистки:** повторный импорт того же файла не сработает  
**С очисткой:** можно импортировать один и тот же файл сколько угодно раз

**Почему сначала устанавливаем `reader.onload`, а потом вызываем `reader.readAsText(file)`:**  
Мы сначала устанавливаем обработчик события (ловушку), а только потом запускаем асинхронную операцию, которая это событие вызовет — иначе событие может произойти до того, как мы успеем установить обработчик.

_(Полный исходный код DataImportExport.jsx представлен в PDF документе)_

## Самостоятельная работа

**Задание 1:** Создайте форму для установки сроков изучения с валидацией. Форма должна включать валидацию, работающую в реальном времени, с понятными и доступными сообщениями об ошибках. Реализуйте доступность для пользователей с ограниченными возможностями (ARIA-атрибуты, навигация с клавиатуры).

**Задание 2:** Добавьте компонент для массового редактирования статусов технологий. Компонент должен позволять выбирать несколько технологий одновременно и корректно применять изменения ко всем выбранным элементам. Обеспечьте доступность формы для пользователей с ограниченными возможностями.

**Задание 3:** Проверьте корректность работы экспорта и импорта данных. Убедитесь, что экспорт создает валидный JSON файл, а импорт правильно обрабатывает ошибки формата и некорректные данные.

---
